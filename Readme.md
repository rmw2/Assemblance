# A semblance of assembly
Learning an assembly language is very helpful for understanding machine operations at a low level, and knowing the ways that that machine translates expressive lines of C source (for example) into individual instructions can help one write more efficient code.
Unfortunately, most tools dedicated to compilers and assembly languages are geared towards experts, and there are relatively few resources available to those trying to learn assembly from scratch.

The purpose of this project is to develop an interactive, browser-based explorer for C90 and x86-64 that illustrates the relationships between source and assembly and provides easy access to information about different assembly mnemonics and registers.
A similar project developed by Matt Godbolt can be found at http://gcc.godbolt.com -- this appears to focus more on comparing the assembly generated by different compilers, while this tool is aimed more at teaching assembly language patterns and concepts to those unfamiliar.

Special thanks to Bob Dondero for his advising during this project, and the x86-64 resources he developed for Princeton's COS217: Systems Programming.

## Progress
* (3/9)  Compiled dictionary of assembly mnemonics in static/ref.json
* (3/10) Boilerplate for uploading a file to the server
* (3/11) Render uploaded source file in template
* (3/11) Perform source-assembly line-matching on backend
* (3/19) Assembly tokens parsed and each returned in a different div
* (3/20) Tooltips on mnemonics are functional
  - All text generated on backend, visibility controlled via CSS
  - Current formatting is acceptable, could be improved
* (3/20) Line-matching is functional
  - corresponding lines of c and asm are wrapped in divs of the same class
* (3/20) Extraneous compiler-generated assembly labels and directives are ignored in output
* (3/21) Fixed line-matching bug and line numbering
* (3/21) Moved compilation to server-side
  - Now user only uploads source, both .s and .o files are generated on the server by gcc 4.8.1
  - Eliminates session bug resulting from having to upload multiple files
* (3/21) Added parsing and syntax highlighting for registers and labels
  - Now can recognize mnemonics, registers, and labels.
* (3/23) Began work on parsing debugging info
  - Currently have a dicitonary of memory locations by funciton and their corresponding symbols, declaration lines, and types.  Unfortunately the memory location is still in an opaque format.  Trying to figure out exactly the relationship between these numbers and stack/base pointer offsets.
* (3/23) Fixed tokenizing bug with quotes and whitespace
* (3/25) Started branch for more advanced animations/interactions with javascript
  - Added scrollbars to each panel
  - Working on horizontally aligning lines of C with corresponding blocks of assembly, to be triggered by a click event
  - Broke tooltip popups, need to re-style them
* (3/27) Can successfully determine locations of variables stored on the stack and in registers
  - Markup not yet completed / matching not visible browser side

## TODO
* Finish variable name / memory address correspondance
  - Add lookup to memory location dictionary to token markup
  - Add another hover-enabled tooltip with symbol, type, and declaration line
  - Highlight declaration line in source on hover (with javascript, somehow encode declaration line in attributes for token? data-decl-line=$LINE)
* Improve aesthetics
  - scale font size to screen width
  - add operand size and type to tooltips
  - give option to align bits of assembly with the corresponding bit of c, and add independent scrolling to the C/asm panels
* Improve backend assembly parsing: identify addressing modes, registers, mnemonics, labels
  - make better regular expressions
  - handle first token differently from subsequent tokens for each line
* Parse DWARF format for debug info, specifically matching local variables to stack offsets, arguments to registers, etc.

## Limitations
* At this point the project will be restricted to the same subset of x86-64 used by Princeton's COS217.  Specifically this excludes floating point arithmetic and assumes that functions take no more than six arguments, and that structs are not passed as arguments.
